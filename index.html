<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shared Whiteboard</title>
<style>
  body { margin: 0; display: flex; flex-direction: column; align-items: center; font-family: sans-serif; background: #f7f7f7; }
  #toolbar { margin: 10px; display: flex; align-items: center; gap: 10px; }
  button { cursor: pointer; background: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 6px; display: flex; align-items: center; justify-content: center; }
  button.selected { border: 2px solid #333; }
  input[type="color"] { width: 40px; height: 40px; border: none; cursor: pointer; }
  canvas { border: 1px solid #ccc; background: white; display: block; margin-top: 10px; }
  svg { width: 24px; height: 24px; }
</style>
</head>
<body>

<div id="toolbar">
  <input type="color" id="colorPicker" value="#000000">

  <!-- Brush Icon -->
  <button data-tool="brush" class="selected" title="Brush">
    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M7 16l5-5 5 5v3H7v-3z"/><path fill="currentColor" d="M2 20h20v2H2v-2z"/></svg>
  </button>

  <!-- Eraser Icon -->
  <button data-tool="eraser" title="Eraser">
    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M16.24 3.56L20.44 7.76l-9.9 9.9-4.2-4.2 9.9-9.9zM3 17.25V21h3.75l11-11-3.75-3.75-11 11z"/></svg>
  </button>

  <!-- Paint Bucket Icon -->
  <button data-tool="fill" title="Paint Bucket">
    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 2H5a2 2 0 0 0-2 2v16l4-4h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"/></svg>
  </button>

  <button data-size="small" title="Small">S</button>
  <button data-size="medium" title="Medium">M</button>
  <button data-size="large" title="Large">L</button>
  <button data-size="xlarge" title="XL">XL</button>

  <button id="clear" title="Clear All">Clear</button>
</div>

<canvas id="canvas" width="1000" height="700"></canvas>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorPicker = document.getElementById('colorPicker');

const sizes = { small: 2, medium: 5, large: 10, xlarge: 20 };
let currentTool = 'brush';
let currentSize = sizes.medium;
let currentColor = colorPicker.value;
let isDrawing = false;
let lastX = 0, lastY = 0;

colorPicker.addEventListener('input', e => currentColor = e.target.value);

// ===== Draw Line =====
function drawLine(x0, y0, x1, y1, color, size, tool, emit=false){
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
  ctx.strokeStyle = tool==='eraser' ? 'white' : color;
  ctx.lineWidth = size;
  ctx.lineCap = 'round';
  ctx.stroke();
  ctx.closePath();
  if(!emit) return;
  socket.emit('draw', {x0,y0,x1,y1,color,size,tool});
}

// ===== Flood Fill =====
function hexToRgba(hex){
  const bigint = parseInt(hex.slice(1),16);
  return [(bigint>>16)&255,(bigint>>8)&255, bigint&255,255];
}

function colorMatch(a,b){ return a[0]===b[0] && a[1]===b[1] && a[2]===b[2] && a[3]===b[3]; }

function floodFill(x, y, fillColor, emit=false){
  const img = ctx.getImageData(0,0,canvas.width,canvas.height);
  const data = img.data;
  const w = img.width, h = img.height;
  const stack = [[x,y]];
  const targetPos = (y*w + x)*4;
  const targetColor = [data[targetPos],data[targetPos+1],data[targetPos+2],data[targetPos+3]];
  const replacementColor = hexToRgba(fillColor);
  if(colorMatch(targetColor,replacementColor)) return;

  while(stack.length){
    const [cx,cy] = stack.pop();
    let pos = (cy*w + cx)*4;

    while(cy>=0 && colorMatch([data[pos],data[pos+1],data[pos+2],data[pos+3]],targetColor)){
      cy--; pos-=w*4;
    }
    cy++; pos+=w*4;
    let reachLeft=false, reachRight=false;
    while(cy<h && colorMatch([data[pos],data[pos+1],data[pos+2],data[pos+3]],targetColor)){
      data[pos]=replacementColor[0]; data[pos+1]=replacementColor[1]; data[pos+2]=replacementColor[2]; data[pos+3]=replacementColor[3];

      if(cx>0){
        if(colorMatch([data[pos-4],data[pos-3],data[pos-2],data[pos-1]],targetColor) && !reachLeft){ stack.push([cx-1,cy]); reachLeft=true; }
        else reachLeft=false;
      }
      if(cx<w-1){
        if(colorMatch([data[pos+4],data[pos+5],data[pos+6],data[pos+7]],targetColor) && !reachRight){ stack.push([cx+1,cy]); reachRight=true; }
        else reachRight=false;
      }

      cy++; pos+=w*4;
    }
  }
  ctx.putImageData(img,0,0);
  if(emit) socket.emit('fill',{x,y,color:fillColor});
}

// ===== Mouse Events =====
canvas.addEventListener('mousedown', e => {
  const x = e.offsetX, y = e.offsetY;
  if(currentTool==='fill'){ floodFill(x,y,currentColor,true); return; }
  isDrawing=true; lastX=x; lastY=y;
});

canvas.addEventListener('mouseup',()=>isDrawing=false);
canvas.addEventListener('mouseout',()=>isDrawing=false);
canvas.addEventListener('mousemove',e=>{
  if(!isDrawing || currentTool==='fill') return;
  drawLine(lastX,lastY,e.offsetX,e.offsetY,currentColor,currentSize,currentTool,true);
  lastX=e.offsetX; lastY=e.offsetY;
});

// ===== Socket Events =====
socket.on('draw',data=>drawLine(data.x0,data.y0,data.x1,data.y1,data.color,data.size,data.tool,false));
socket.on('fill',data=>floodFill(data.x,data.y,data.color,false));
socket.on('init',history=>{
  history.forEach(data=>{
    if(data.tool==='fill') floodFill(data.x,data.y,data.color,false);
    else drawLine(data.x0,data.y0,data.x1,data.y1,data.color,data.size,data.tool,false);
  });
});
socket.on('clear',()=>ctx.clearRect(0,0,canvas.width,canvas.height));

// ===== Toolbar Buttons =====
document.querySelectorAll('#toolbar button[data-tool]').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('#toolbar button[data-tool]').forEach(b=>b.classList.remove('selected'));
    btn.classList.add('selected');
    currentTool=btn.dataset.tool;
  });
});

document.querySelectorAll('#toolbar button[data-size]').forEach(btn=>{
  btn.addEventListener('click',()=>currentSize=sizes[btn.dataset.size]);
});

document.getElementById('clear').addEventListener('click',()=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  socket.emit('clear');
});
</script>
</body>
</html>
